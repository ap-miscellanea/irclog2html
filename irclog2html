#!/usr/bin/env perl
use 5.010;
use strict;
use utf8;

sub parse_query {
	require Hash::MultiValue;
	return Hash::MultiValue->new(
		map { split /=/, $_, 2 }
		split /[&;]/,
		$ENV{'QUERY_STRING'}
	);
}

sub response {
	my ( $status, %headers ) = @_;
	$headers{'Content-Type'} //= 'text/plain';
	print "Status: $status\r\n";
	print map { "$_: $headers{$_}\r\n" } sort keys %headers;
	print "\r\n";
	given ( $status ) {
		when ( 404 )  { print "$status Not Found"     }
		when ( 403 )  { print "$status Access Denied" }
		when ( /^4/ ) { print "$status Request Error" }
		when ( /^5/ ) { print "$status Server Error"  }
	}
	exit if 200 ne $status;
}

sub openf {
	my ( $fn ) = @_;
	my $binmode = ':encoding(UTF-8)';
	if ( '-' eq $fn ) { binmode STDIN, $binmode; return \*STDIN }
	open my $fh, "<$binmode", $fn or return;
	return $fh;
}

if ( 'CGI/1.1' ne ( $ENV{'GATEWAY_INTERFACE'} // '' ) ) {
	eval 'use Getopt::Long 2.24, qw( :config bundling no_ignore_case no_auto_abbrev ); 1' or die $@;
	GetOptions(
		'from|f=s' => \my $opt_from,
		'to|t=s'   => \my $opt_to,
		'noconv|N' => \my $opt_noconvert,
	) or die "\n";

	my $log = ChatLog->new(
		title      => "@ARGV",
		show_from  => $opt_from,
		show_to    => $opt_to,
	);

	for my $fn ( @ARGV ? @ARGV : '-' ) {
		my $fh = openf $fn or die "Couldn't open $fn to read: $!\n";
		$log->add( $fh );
	}

	print $opt_noconvert ? $log->as_text : $log->as_html;
}
else {
	response 405 if 'GET' ne $ENV{'REQUEST_METHOD'};

	my $fn = $ENV{'PATH_TRANSLATED'} // response 404;

	my $fh = openf $fn or response $!{ENOENT} ? 404 : $!{EACCES} ? 403 : 500;

	my $p = parse_query;

	my $do_convert = not $p->{'src'};

	my $log = ChatLog->new(
		title          => $fn,
		show_from      => $p->{'f'},
		show_to        => $p->{'t'},
	)->add( $fh );

	response 200, 'Content-Type' => $do_convert
		? 'text/html; charset=us-ascii'
		: 'text/plain; charset=utf-8';

	print $do_convert
		? $log->as_html( show_skip_link => not $p->{'noskip'} )
		: $log->as_text;
}

#######################################################################

BEGIN {

package ChatLog;
use Object::Tiny qw( lines hashes title show_from show_to );

use Encode ();
use Digest::SHA1 ();

my %ent = qw( < lt > gt & amp ' #39 " #34 );
sub _encode_entities { s!([<>&'"])!&$ent{$1};!g for my @c = @_; @c[ 0 .. $#c ] }

# regex by John Gruber
# http://daringfireball.net/2010/07/improved_regex_for_matching_urls
sub _url_rx () { qr{\b((?:[a-z][\w-]+:(?:/{1,3}|[a-z0-9%])|www\d{0,3}[.|[a-z0-9.\-]+[.[a-z]{2,4}/)(?:[^\s()<>]+|\(([^\s()<>]+|(\([^\s()<>]+\)))*\))+(?:\(([^\s()<>]+|(\([^\s()<>]+\)))*\)|[^\s`!()\[\{\};:'".,<>?«»“”‘’]))}i }

sub new {
	my $class = shift;
	return $class->SUPER::new( @_, lines => [], hashes => [] );
}

sub _linkify {
	my ( $url ) = @_;
	return '' if not defined $url;

	my @seg = map { _encode_entities $_ } map m!(.{1,50})!sg, split m{(?<=/)(?!/)}, $url;
	my $link  = join '', @seg;
	my $label = join '<wbr />', @seg; # deprecated :-( need a soft-hyphen w/o the hyphen...

	# FIXME referer hiding should probably be optional?
	return qq'<a href="$link" rel="noreferrer" tabindex="1">$label</a>';
}

sub push {
	my $self = shift;
	my ( $line ) = @_;

	my $lines        = $self->lines;
	my $hashes       = $self->hashes;
	my $from_hash    = $self->show_from;
	my $to_hash      = $self->show_to;

	return if $to_hash and @$hashes and $hashes->[-1] eq $to_hash;

	my $hash = Digest::SHA1::sha1_base64 Encode::encode 'UTF-8', $line;
	return '0E0' if $from_hash and $hash ne $from_hash and not @$lines;

	push @$hashes, $hash;
	push @$lines,  $line;
}

sub add {
	my $self = shift;
	my ( $next ) = @_;

	my $next = sub { <$next> } if 'CODE' ne ref $next;

	local *_;
	while ( defined( $_ = $next->() ) ) {
		chomp;
		$self->push( $_ ) or last;
	}

	return $self;
}

sub as_text {
	my $self = shift;
	return Encode::encode 'UTF-8', ( join "\n", @{ $self->lines }, '' ), Encode::FB_HTMLCREF;
}

sub as_html {
	my $self = shift;
	my %arg = @_;

	my $url_rx = _url_rx;
	my $do_skip_link = $arg{'show_skip_link'};

	my $lines  = $self->lines;
	my $hashes = $self->hashes;
	my $body = join '', map {
		my $hash = $hashes->[$_];
		my ( $nick, $line ) = split /(?<=>) /, $lines->[$_], 2;

		$line =~ s{\G(.*?)$url_rx?}{ _encode_entities($1) . _linkify($2) }eg;

		my $meta;
		$meta  = sprintf '<a href="?f=%s" class="skip" tabindex="9"></a>', $hash if $do_skip_link;
		$meta .= sprintf '<a href="#l%s" id="l%1$s" class="perma" tabindex="9">%s</a> ', $hash, _encode_entities $nick;

		sprintf "<div>%s</div>\n", (
			join '' => map { sprintf "<tt%s</tt>", $_ }
			' class="crud">' . $meta , ' class="text">' . $line
		);
	} 0 .. $#$lines;

	my $title = $self->title;
	$title  =~ s/\.(?:irc)?log(?: |\z)//g if $title;
	$title  =~ s!(?: |\A)([^ ]*/)!!g if $title;
	$title .= ' ' if $title;
	$title .= '(' . @{ $self->lines } . ' lines)';

	my $page = qq(
		<html>
		<head>
		<title>$title « irclog2html</title>
		<style type="text/css">
		body { margin: 0.5em 0 }
		a.perma { text-decoration: none; color: inherit }
		a.skip { text-decoration: none }
		a.skip:before { content: '\\A0\\21A7\\A0' }
		div {
			margin: 0;
			padding: 0.05em 0;
			vertical-align: top;
			line-height: 1.4;
		}
		.crud { display: table-cell; white-space: pre }
		.text { display: table-cell; white-space: pre-wrap }
		tt { font-size: 13px }
		</style>
		</head>
		<body>
		$body
		</body>
		</html>
	);

	$page =~ s!^\t+!!mg;
	$page =~ s!^\n+!!;

	return Encode::encode 'us-ascii', $page, Encode::FB_HTMLCREF;
}

}
