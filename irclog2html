#!/usr/bin/env perl
use 5.010;
use strict;
use utf8;

sub parse_query {
	require Hash::MultiValue;
	return Hash::MultiValue->new(
		map { split /=/, $_, 2 }
		split /[&;]/,
		$ENV{'QUERY_STRING'}
	);
}

sub response {
	my ( $status, $headers, $body ) = @_;
	( $headers, $body ) = ( {}, $headers ) if 'HASH' ne ref $headers;
	$headers->{'Content-Type'} //= 'text/plain';
	print "Status: $status\r\n";
	print map { "$_: $headers->{$_}\r\n" } sort keys %$headers;
	print "\r\n";
	given ( $status ) {
		when ( defined $body ) { print $body }
		when ( 404 )  { print "$status Not Found"     }
		when ( 403 )  { print "$status Access Denied" }
		when ( /^4/ ) { print "$status Request Error" }
		when ( /^5/ ) { print "$status Server Error"  }
	}
	exit;
}

sub openf {
	my ( $fn ) = @_;
	my $binmode = ':encoding(UTF-8)';
	if ( '-' eq $fn ) { binmode STDIN, $binmode; return \*STDIN }
	open my $fh, "<$binmode", $fn or return;
	return $fh;
}

if ( $0 !~ /\.cgi\z/ ) {
	eval 'use Getopt::Long 2.24, qw( :config bundling no_ignore_case no_auto_abbrev ); 1' or die $@;
	GetOptions( 'from|f=s' => \my $opt_from ) or die "\n";

	my $log = HTMLLog->new( title => "@ARGV", show_from => $opt_from );

	for my $fn ( @ARGV ? @ARGV : '-' ) {
		my $fh = openf $fn or die "Couldn't open $fn to read: $!\n";
		$log->add( $fh );
	}

	print $log->page;
}
else {
	response 405 if 'GET' ne $ENV{'REQUEST_METHOD'};

	my $fn = $ENV{'PATH_TRANSLATED'} // response 404;

	my $fh = openf $fn or response $!{ENOENT} ? 404 : $!{EACCES} ? 403 : 500;

	my $p = parse_query;

	my $do_convert = not $p->{'src'};

	my $hdr; $hdr->{'Content-Type'} = $do_convert
		? 'text/html; charset=us-ascii'
		: 'text/plain; charset=utf-8';

	response 200, $hdr, HTMLLog->new(
		title          => $fn,
		show_skip_link => 1,
		show_from      => $p->{'f'},
		do_convert     => $do_convert,
	)->add( $fh )->page;
}

#######################################################################

BEGIN {

package HTMLLog;
use Object::Tiny qw( lines title show_from show_skip_link do_convert );

use Encode ();
use Digest::SHA1 ();

my %ent = qw( < lt > gt & amp ' #39 " #34 );
sub encode_entities { s!([<>&'"])!&$ent{$1};!g for my @c = @_; @c[ 0 .. $#c ] }

# regex by John Gruber
# http://daringfireball.net/2010/07/improved_regex_for_matching_urls
sub url_rx { qr{\b((?:[a-z][\w-]+:(?:/{1,3}|[a-z0-9%])|www\d{0,3}[.|[a-z0-9.\-]+[.[a-z]{2,4}/)(?:[^\s()<>]+|\(([^\s()<>]+|(\([^\s()<>]+\)))*\))+(?:\(([^\s()<>]+|(\([^\s()<>]+\)))*\)|[^\s`!()\[\{\};:'".,<>?«»“”‘’]))}i }

sub new {
	my $class = shift;
	return $class->SUPER::new( do_convert => 1, @_, lines => [] );
}

sub linkify {
	my $self = shift;
	my ( $url ) = @_;
	return '' if not defined $url;

	my @seg = map { encode_entities $_ } map m!(.{1,50})!sg, split m{(?<=/)(?!/)}, $url;
	my $link  = join '', @seg;
	my $label = join '<wbr />', @seg;

	# FIXME referer hiding should probably be optional?
	return qq'<a href="$link" rel="noreferrer" tabindex="1">$label</a>';
}

sub add {
	my $self = shift;
	my ( $next ) = @_;

	my $next = sub { <$next> } if 'CODE' ne ref $next;

	my $url_rx       = $self->url_rx;
	my $from_hash    = $self->show_from;
	my $lines        = $self->lines;
	my $do_convert   = $self->do_convert;

	local *_;
	while ( defined( $_ = $next->() ) ) {
		chomp;

		my $line_id = Digest::SHA1::sha1_base64 Encode::encode 'UTF-8', $_;
		next if $from_hash and $line_id ne $from_hash and not @$lines;

		if ( not $do_convert ) {
			push @$lines, $_;
			next;
		}

		my ( $nick, $line ) = split /(?<=>) /, $_, 2;

		$line =~ s{\G(.*?)$url_rx?}{ encode_entities($1) . $self->linkify($2) }eg;

		my $meta;
		$meta  = sprintf '<a href="?f=%s" class="skip" tabindex="9"></a>', $line_id if $self->show_skip_link;
		$meta .= sprintf '<a href="#l%s" id="l%1$s" class="perma" tabindex="9">%s</a> ', $line_id, encode_entities $nick;

		push @$lines, (
			sprintf "<table><tr>%s</tr></table>\n",
			join '' => map { sprintf "<td%s</td>", $_ }
			' class="crud">' . $meta , ' class="text">' . $line
		);
	}

	return $self;
}

sub page {
	my $self = shift;

	return Encode::encode 'UTF-8', ( join "\n", @{ $self->lines }, '' ), Encode::FB_HTMLCREF
		if not $self->do_convert;

	my $title = $self->title;
	$title  =~ s/\.(?:irc)?log(?: |\z)//g if $title;
	$title  =~ s!(?: |\A)([^ ]*/)!!g if $title;
	$title .= ' ' if $title;
	$title .= '(' . @{ $self->lines } . ' lines)';

	my $page = qq(
		<html>
		<head>
		<title>$title « irclog2html</title>
		<style type="text/css">
		body { margin: 0.5em 0 }
		a.perma { text-decoration: none; color: inherit }
		a.skip { text-decoration: none }
		a.skip:before { content: '\\A0\\21A7\\A0' }
		table { border-collapse: collapse }
		td {
			margin: 0;
			padding: 0.075em 0;
			font-family: monospace;
			font-size: 12px;
			vertical-align: top;
			line-height: 1.5;
		}
		td.crud { white-space: pre }
		td.text { white-space: pre-wrap }
		</style>
		</head>
		<body>
		${\join '', @{ $self->lines } }
		</body>
		</html>
	);

	$page =~ s!^\t+!!mg;
	$page =~ s!^\n+!!;

	return Encode::encode 'us-ascii', $page, Encode::FB_HTMLCREF;
}

}
